# Copilot Agent Instructions

## Project Overview
This is a lightweight multiplayer shmup (shoot-em-up) game designed for office deployment.

## Core Architecture (CRITICAL - Always Reference)
- **Single-server, single-game-world** design (see GAME_DESIGN.md)
- **No rooms/lobbies** - all players in same shared world
- **5-minute matches** with 2-minute intermissions
- **Handle reservation system** for player identity
- **Relegation system** for inactive players to viewer status

## Development Constraints
- **Time-boxing**: All tasks must be 15-20 minutes maximum
- **Iteration limit**: Maximum 3 attempts per issue before escalation
- **Context requirement**: Always read GAME_DESIGN.md before architectural decisions
- **Template usage**: Use existing templates in .github/copilot-tasks/ and .github/ISSUE_TEMPLATE/

## Technology Stack
- **Package Manager**: Yarn (NOT npm) - use `yarn` commands for all package operations
- **Monorepo**: Yarn workspaces - use `yarn workspace <name> <command>` for workspace-specific operations
- **Backend**: Vanilla Node.js (NOT TypeScript), WebSocket via `ws` library for real-time communication
- **Frontend**: Native HTML5 Canvas API (NO external game engines like PixiJS/Unity)
- **UI Framework**: Vue.js for UI components (chat, lobby, HUD) - NOT game canvas
- **Physics**: Planck.js for deterministic simulation (shared browser/Node.js)
- **JavaScript**: Vanilla JS (NOT TypeScript) - prioritizing rapid prototyping and iteration speed
- **Testing**: Jest for backend unit tests, Playwright for E2E (not yet configured)
- **Storage**: In-memory initially (no database)
- **Development**: Docker Compose for orchestration (`docker-compose up -d`)

## Common Patterns
1. **State Management**: Game state stored in memory on server
2. **Communication**: WebSocket messages for real-time updates
3. **Player Management**: Handle-based identity system
4. **Testing**: Test setup in 5-7 minutes, implementation in 7-10 minutes

## Code Style & Workflow Conventions
- **JavaScript**: Use modern ES modules and async/await patterns, NO TypeScript
- **Linting**: All code must pass ESLint checks (`yarn lint:all`)
- **Branch naming**: `feature/<issue-number>-short-desc` or `bugfix/<issue-number>-short-desc`
- **Commit workflow**: Create branch â†’ implement â†’ test â†’ lint â†’ commit â†’ push
- **Documentation**: Use JSDoc comments for function documentation instead of TypeScript types
- **Logging**: Use Winston structured format for backend logging
- **File organization**: Follow existing patterns in src/ directories

## Common Development Commands
- **Setup**: `yarn install` (root level for all workspaces)
- **Docker**: `docker-compose up -d` (start development environment)
- **Development**: `yarn dev:backend` and `yarn dev:frontend` 
- **Testing**: `yarn test:all` (full suite), `yarn test:unit`, `yarn test:integration`
- **Quality**: `yarn lint:all` (must pass before commits)
- **Workspace-specific**: `yarn workspace <backend|frontend|test> <command>`

## Task Execution Rules
1. **Before starting**: Read relevant context files (GAME_DESIGN.md, etc.)
2. **During implementation**: Follow existing patterns and architecture
3. **If stuck**: Comment on issue with specific blocker, don't exceed 3 attempts
4. **Documentation**: Update relevant docs within the 15-20 minute window

## Critical Files to Reference
- `GAME_DESIGN.md` - Complete architecture specification
- `.github/PROJECT_MANAGEMENT.md` - Workflow and process rules
- `.github/COPILOT_WORKFLOW.md` - Agent-specific guidelines

## Escalation Triggers
- Task exceeds 20 minutes
- Architecture conflicts with GAME_DESIGN.md
- Dependencies missing from previous tasks
- Scope creep beyond single focused change

## Success Criteria
- Working code with tests
- Follows single-server architecture
- Maintains 15-20 minute scope
- Updates documentation appropriately

## ðŸŽ® Game Design & Technical Architecture

### Core Game Mechanics
- **Genre**: 2D space combat (asteroids-style movement + heat management)
- **Physics**: Planck.js (deterministic across browser/Node.js)
- **Rendering**: Canvas API (no framework - pure HTML5 Canvas)
- **Viewport**: Fixed 1024x768 (no zoom/scaling)
- **Movement**: Rotate L/R + thrust (minimal friction)
- **Heat System**: Guns + engines generate heat â†’ overheat = drift until cool
- **Map Size**: 2-5 screen areas (2048x1536 to 5120x3840)

### Visual Architecture
- **Layer 1-3**: Parallax star backgrounds (different scroll rates/directions)
- **Layer 4**: Terrain tilemap (space junk obstacles - subspace/spacewar inspired)
- **Layer 5**: Ships, projectiles, effects
- **Art Style**: Modern pixel art remake (clean, minimal frills)

### Technical Stack
- **Physics**: Planck.js (shared deterministic simulation)
- **Frontend**: Vanilla JS + Canvas API + Vue.js components for UI
- **Backend**: Node.js + Express + WebSocket + Planck.js physics
- **Architecture**: Server-authoritative with client prediction
